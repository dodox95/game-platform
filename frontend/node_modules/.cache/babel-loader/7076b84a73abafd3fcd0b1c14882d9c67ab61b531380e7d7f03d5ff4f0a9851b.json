{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nconst _withScopeId = n => (_pushScopeId(\"data-v-c225134e\"), n = n(), _popScopeId(), n);\nconst _hoisted_1 = {\n  class: \"game-wrapper\"\n};\nconst _hoisted_2 = {\n  ref: \"gameCanvas\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"canvas\", _hoisted_2, null, 512 /* NEED_PATCH */)]);\n}","map":{"version":3,"names":["class","ref","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2"],"sources":["C:\\Users\\doria\\Desktop\\MY WORKSPACE\\DJANGO APPS\\game_platform\\frontend\\src\\views\\AppSnake.vue"],"sourcesContent":["<template>\r\n  <div class=\"game-wrapper\">\r\n    <canvas ref=\"gameCanvas\"></canvas>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \"AppSnake\",\r\n  data() {\r\n    return {\r\n      score: 0,\r\n      canvas: null,\r\n      ctx: null,\r\n      gridSize: 20,\r\n      snake: [],\r\n      food: null,\r\n      direction: \"right\",\r\n      gameInterval: null\r\n    };\r\n  },\r\n  mounted() {\r\n    this.canvas = this.$refs.gameCanvas;\r\n    this.ctx = this.canvas.getContext(\"2d\");\r\n    this.canvas.width = 400;\r\n    this.canvas.height = 400;\r\n\r\n    this.initializeGame();\r\n    document.addEventListener(\"keydown\", this.handleArrowKeys);\r\n  },\r\n  methods: {\r\n    initializeGame() {\r\n      this.snake = [\r\n        { x: 3, y: 2 },\r\n        { x: 2, y: 2 },\r\n        { x: 1, y: 2 }\r\n      ];\r\n      this.spawnFood();\r\n      if (this.gameInterval) clearInterval(this.gameInterval);\r\n      this.gameInterval = setInterval(this.updateGame, 150);\r\n\r\n      this.gameInterval = this.startGameWithInterval(150);\r\n    },\r\n    startGameWithInterval(interval) {\r\n      if (this.gameInterval) clearInterval(this.gameInterval);\r\n      return setInterval(this.updateGame, interval);\r\n    },\r\n    spawnFood() {\r\n      let foodPosition;\r\n      let isFoodOnSnake = true;\r\n      while (isFoodOnSnake) {\r\n        foodPosition = {\r\n          x: 1 + Math.floor(Math.random() * ((this.canvas.width / this.gridSize) - 2)), // -2 and +1 to prevent spawn on wall\r\n          y: 1 + Math.floor(Math.random() * ((this.canvas.height / this.gridSize) - 2))\r\n        };\r\n        isFoodOnSnake = this.snake.some(s => s.x === foodPosition.x && s.y === foodPosition.y);\r\n      }\r\n      this.food = foodPosition;\r\n    },\r\n    updateGame() {\r\n      const head = { ...this.snake[0] };\r\n\r\n      switch (this.direction) {\r\n        case \"right\": head.x++; break;\r\n        case \"left\": head.x--; break;\r\n        case \"up\": head.y--; break;\r\n        case \"down\": head.y++; break;\r\n      }\r\n\r\n      if (this.isCollision(head)) {\r\n        clearInterval(this.gameInterval);\r\n        const playAgain = confirm('Game Over! Do you want to play again?');\r\n        if (playAgain) {\r\n          this.initializeGame();\r\n        } else {\r\n          this.$router.push('/');\r\n        }\r\n        return;\r\n      }\r\n\r\n      this.snake.unshift(head);\r\n\r\n      if (head.x === this.food.x && head.y === this.food.y) {\r\n        this.spawnFood();\r\n        this.score++; // Increment the score when food is eaten\r\n        clearInterval(this.gameInterval); // Clear the old interval\r\n        this.gameInterval = this.startGameWithInterval(150 - this.score); // Increase the speed\r\n        if (this.score > 140) { // To ensure game doesn't become too fast\r\n          this.gameInterval = this.startGameWithInterval(10);\r\n        }\r\n      } else {\r\n        this.snake.pop();\r\n      }\r\n\r\n      this.drawGame();\r\n    },\r\n    isCollision(pos) {\r\n      if (pos.x < 1 || pos.x >= (this.canvas.width / this.gridSize) - 1 ||\r\n          pos.y < 1 || pos.y >= (this.canvas.height / this.gridSize) - 1) {\r\n        return true;\r\n      }\r\n      if (this.snake.some(s => s.x === pos.x && s.y === pos.y)) {\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    drawGame() {\r\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n      // Draw walls\r\n      this.ctx.fillStyle = \"#333\";\r\n      this.ctx.fillRect(0, 0, this.canvas.width, this.gridSize); // Top Wall\r\n      this.ctx.fillRect(0, this.canvas.height - this.gridSize, this.canvas.width, this.gridSize); // Bottom Wall\r\n      this.ctx.fillRect(0, 0, this.gridSize, this.canvas.height); // Left Wall\r\n      this.ctx.fillRect(this.canvas.width - this.gridSize, 0, this.gridSize, this.canvas.height); // Right Wall\r\n\r\n\r\n      // Draw snake\r\n      for (let cell of this.snake) {\r\n        this.ctx.fillStyle = \"green\";\r\n        this.ctx.fillRect(cell.x * this.gridSize, cell.y * this.gridSize, this.gridSize, this.gridSize);\r\n      }\r\n\r\n      // Draw food\r\n      this.ctx.fillStyle = \"red\";\r\n      this.ctx.fillRect(this.food.x * this.gridSize, this.food.y * this.gridSize, this.gridSize, this.gridSize);\r\n\r\n      // Display score at the top\r\n      this.ctx.font = \"20px Arial\";\r\n      this.ctx.fillStyle = \"#000\";\r\n      this.ctx.fillText(\"Score: \" + this.score, 160, 20); // Changed positioning to 25 from bottom\r\n    },\r\n\r\n    \r\n    handleArrowKeys(e) {\r\n      switch (e.key) {\r\n        case \"ArrowUp\": if (this.direction !== 'down') this.direction = \"up\"; break;\r\n        case \"ArrowDown\": if (this.direction !== 'up') this.direction = \"down\"; break;\r\n        case \"ArrowLeft\": if (this.direction !== 'right') this.direction = \"left\"; break;\r\n        case \"ArrowRight\": if (this.direction !== 'left') this.direction = \"right\"; break;\r\n      }\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n.game-wrapper {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 100vh;\r\n  background-color: #f4f4f4;\r\n}\r\n</style>\r\n"],"mappings":";;;EACOA,KAAK,EAAC;AAAc;;EACfC,GAAG,EAAC;AAAY;;uBAD1BC,mBAAA,CAEM,OAFNC,UAEM,GADJC,mBAAA,CAAkC,UAAlCC,UAAkC,8B"},"metadata":{},"sourceType":"module","externalDependencies":[]}